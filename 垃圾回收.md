java技术体系所提倡的自动内存管理可以归结为自动化解决两个问题：
* 给对象分配内存
* 回收分配给对象的内存

### 给对象分配内存
* 往大方向说就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接的栈上分配）。对象主要分配在新生代的Eden区上，如果启动本地线程分配缓存（TLAB），将按线程优先在TLAB上分配。少数情况也会直接在老年代分配。分配细节取决于当前使用的是哪一种垃圾收集器和虚拟机中与内存相关的参数设置。
* 分配策略
    * 大多数情况在新生代Eden区中分配
    * 大对象直接进入老年代
    * 长期存活的对象进入老年代

### 回收分配给对象的内存
* 程序计数器，虚拟机栈，本地方法栈的内存回收
    * 这三个区域随着线程而生，随线程而灭，因此这几个区域的内存分配和回收基本都是确定的。
* java堆和方法区的内存回收
    * 如何判断一个对象可以回收（对象是存在堆里的，堆唯一存储的就是对象，因此是不是可以称之为堆内存的回收）
        * 引用计数法
            * 解释：给对象添加一个引用计数器，没当一个地方引用时就+1，引用失效时就-1。为0时表示这个对象没有被引用，可以被回收。
            * 缺点：无法解决A引用B,B引用A的情况。
        * 可达性分析法
            * 将GC Roots作为对象的起始点，当一个对象到GC roots没有任何引用链时，表示该对象可以被回收。
            * 关于引用：
                * 强引用
                * 软引用
                * 弱引用
                * 虚引用
* 回收方法区
    * 很多人认为方法区是没有垃圾回收的。因为方法区的回收性价比一般本地。
    * 方法区回收什么？
        * 废弃的常量
            * 回收废弃的常量与回收堆中的对象类似
        * 无用的类（如何判断一个类无用，并且可以被回收，（注意这里只是可以被回收，不是像对象一样必然会被回收））
            * 该类所有的实例都已经被回收，即java堆中不存在该类任何实例
            * 加载该类的classLoader已经被回收
            * 该类对应的java.long.Class对象没有在任何地方被引用，无任何地方通过反射访问该类的方法。
* 垃圾收集算法
    * 标记清除算法
        * 流程：标记出需要回收的对象，标记完成后统一回收。
        * 优点：实现简单
        * 缺点：
            * 效率低，标记，清除两个过程效率比较低，
            * 空间问题，回收后产生大量不连续的内存碎片，当程序需要分配较大对象时，没有足够连续的存储空间，不得不再次触发GC
    * 复制算法
        * 流程:将内存划分为两个部分（A和B），每次只使用其中一部分(假如A)，当触发GC时，将存活的对象复制到另一部分(B)。然后清除A。
        * 优点：因为复制过去的对象时绝对工整的，所以不会产生大量内存碎片，每次只要一动指针就可以，高效，实现简单。
        * 缺点：将内存分为两部分，有一部分空闲。可用内存缩小了。对象存活多时，要频繁复制，效率低。
    * 标记整理算法
        * 流程：在标记清除的基础上，让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。
    * 分代收集算法
        * 根据对象存活周期的不同，划分为几块。一般把java堆划分为新生代和老年代，然后根据各个年代的特点采用最适当的算法。新生代中每次GC都会发现大量对象死去，采用复制算法，而老年代则采用标记整理或者标记清除的算法。
